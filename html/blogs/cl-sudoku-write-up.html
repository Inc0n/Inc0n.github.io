<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-01-11 Sun 02:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Me writing my sudoku solver</title>
<meta name="author" content="Danny" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Me writing my sudoku solver</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org937be74">1. Introduction</a>
<ul>
<li><a href="#org892148f">1.1. Layout and the structure of this "blog"</a></li>
<li><a href="#org5c7d6cf">1.2. Why I wanted to write this Sudoku solver</a></li>
</ul>
</li>
<li><a href="#orgaf7eb93">2. Introduction to Sudoku</a></li>
<li><a href="#orgafabb15">3. Algorithm approach</a>
<ul>
<li><a href="#org9aa01de">3.1. How to translate into lisp code</a></li>
<li><a href="#org6ae3f81">3.2. More on encoding</a></li>
</ul>
</li>
<li><a href="#org8542daa">4. the second version</a></li>
<li><a href="#orga87bb33">5. the third version</a>
<ul>
<li><a href="#org74701af">5.1. motivation</a></li>
<li><a href="#org9883dac">5.2. progress</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Encountered a stuck solution problem
</p>
<div id="outline-container-org937be74" class="outline-2">
<h2 id="org937be74"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org892148f" class="outline-3">
<h3 id="org892148f"><span class="section-number-3">1.1.</span> Layout and the structure of this "blog"</h3>
</div>
<div id="outline-container-org5c7d6cf" class="outline-3">
<h3 id="org5c7d6cf"><span class="section-number-3">1.2.</span> Why I wanted to write this Sudoku solver</h3>
<div class="outline-text-3" id="text-1-2">
<p>
I have tried writing a Sudoku solver before, one completed using a very simple brute-force depth-first backtrack searcher in C++ for an university assignment, another using a constraint based depth-first searcher in Clojure, in common lisp, etc, <i>in-completed</i>.
</p>

<p>
The simple brute-force was elegant, efficient and does the job, however, I have thought about how I myself solves the sudoku when I see it right in front of me, I want to make a program that solve the sudoku that way. This is the main motivation with this program, and there are two main goals behind this attempt:
</p>

<ol class="org-ol">
<li>to see to myself finishing a project from start to finish</li>
<li>to challenge myself, to complete something that I hadn't completed individually yet and with sudoku it isn't something too difficult that I would give up mid-way like many times before.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgaf7eb93" class="outline-2">
<h2 id="orgaf7eb93"><span class="section-number-2">2.</span> Introduction to Sudoku</h2>
<div class="outline-text-2" id="text-2">
<p>
Let's go through the basics of a sudoku, i.e. what is a sudoku.
</p>

<p>
The rule and the goal of sudoku is as follows: fill in the 9 by 9 grid with numbers from 1 to 9 in each columns and rows such that all columns, rows, and sub-grid contain a number from 1 to 9 uniquely. Here are some properties of a typical 9 by 9 sudoku:
</p>

<ul class="org-ul">
<li>9 rows, each labelled with 'i's</li>
<li>9 columns, each labelled with 'j's</li>
<li>and 9 sub-grid as seen in the ascii diagram below labelled from A to I</li>
</ul>

<pre class="example" id="orgf605f6a">
   jjj jjj jjj
  ―――――――――――――
i │...│...│...│
i │.A.│.B.│.C.│
i │...│...│...│
  ―――――――――――――
i │...│...│...│
i │.D.│.E.│.F.│
i │...│...│...│
  ―――――――――――――
i │...│...│...│
i │.G.│.H.│.I.│
i │...│...│...│
  ―――――――――――――
</pre>

<p>
For example, the following are "illegal":
</p>
<pre class="example" id="org3ba86e5">
―――――――――――――
│251│...│..1│
│349│...│..2│
│286│...│..3│
―――――――――――――
│...│...│..4│
│...│...│..7│
│...│...│..8│
―――――――――――――
│...│...│..6│
│...│...│..5│
│123│455│789│
―――――――――――――
</pre>
</div>
</div>
<div id="outline-container-orgafabb15" class="outline-2">
<h2 id="orgafabb15"><span class="section-number-2">3.</span> Algorithm approach</h2>
<div class="outline-text-2" id="text-3">
<p>
Solving Sudoku is a solved and known problem, there are many widely available algorithms for solving Sudoku. For example, in as part of my University programming course, the most common approach was to use back-tracking. This time I want to experiment and figure out an approach.
</p>

<p>
Now this is a random sudoku I copied from one of the sudoku sites, which I googled for.
</p>

<pre class="example" id="org3ae44c0">
―――――――――――――
│...│345│.2.│
│349│7.6│..1│
│2.6│..1│47.│
―――――――――――――
│1.2│.79│.85│
│59.│...│...│
│.6.│...│219│
―――――――――――――
│91.│..7│.42│
│.27│913│.6.│
│...│...│...│
―――――――――――――
</pre>

<pre class="example" id="org3b2142c">
―――――――――――――
│...│345│.2.│
│349│7.6│..1│
│2.6│..1│47.│
―――――――――――――
│1.2│.79│.85│
│59.│...│...│
│.6.│...│219│
―――――――――――――
│91.│..7│.42│
│.27│913│.6.│
│...│...│...│
―――――――――――――
</pre>

<p>
I solved sudoku before, this time I want to come up with an algorithm that almost approach a sudoku like how I approached it as a human. So, how do I usually solve a sudoku problem?
</p>

<p>
First, I would look through the entire sudoku itself 9 by 9, simply with a glance, it's done with a combination of subconscious and the conscious! Then I would start to look at a position and start to reason what numbers can be placed at this position. For instance, at <code>(0,0)</code> there are 3,4,5 and 2 on the same row then column-wise, there are 3,2,1,5 and 9 reading down the first column in order. Combining the two gives a set of 1,2,3,4,5,,,9 with 6,7,8 missing. Ouu, but hang on I've missed out on the sub-grid A, which gives another 6. Finally that leaves the available candidates as either 7 or 8.
</p>

<p>
Actually we can narrow one step further, by taking advantage of the information from the other sub-grids, for instance, 7s in B and C have occupied the bottom two lanes, then the 7 must be in the top row for grid A. And then the same can be done for sub-grid D and G (which are the two sub-grids below A) etc.
</p>

<p>
Ok the above is what my brain does by doing a series of reasoning to eliminate and find out the right candidate or candidates, in this case its plural because there are multiple choices. By repeating this methodology, eventually there will be one position that will only have one possible candidate and the domino fall from there and after X number of steps the sudoku is solved.
</p>
</div>
<div id="outline-container-org9aa01de" class="outline-3">
<h3 id="org9aa01de"><span class="section-number-3">3.1.</span> How to translate into lisp code</h3>
<div class="outline-text-3" id="text-3-1">
<p>
First of all, a data-structure is needed to hold the representation of a sudoku board in memory. In this case it's trivia to select a 2d array. In other more complicated computer problems, choosing and implementing the right data-structure will often help facilitate progress rather than hinder it, and choosing poorly will cause hindrance.
</p>

<p>
Anyhow, with a 2d array, the rows of a sudoku can be accessed with <code>O(1)</code> time. Accessing the columns is requires a bit more work. Although these matters less compared to the algorithm as because accessors for rows and columns are effectively function calls and the cost of the function in this case being row is both faster and cheaper can be optimized later on.
</p>

<p>
Moving onto the algorithm side, the program will start looking at one position at a time. For a position (i,j) it will look into the i-th row and j-th column and starts filtering down the possible candidates from there.
</p>

<p>
Normally, I would use a set to represent the combination of unique numbers from the row and column, for instance, in <a href="#org5a78f53">numbers in 1st row</a> we have the numbers from 1st row, and &lt;&gt; is the 1st column. The combined set is as shown in &lt;&gt;, with &lt;&gt; showing the missing numbers for that position.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Numbers in 1st row</caption>

<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(2 3 4 5)</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Numbers in 1st column</caption>

<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(1 2 3 5 9)</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Numbers in 1st row and 1st column</caption>

<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(1 2 3 4 5 9)</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Numbers missing with consideration in 1st row and 1st column</caption>

<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(6 7 8)</td>
</tr>
</tbody>
</table>

<p>
Set is a good tool for holding the data I need. However, I wanted to try something different this time, with compactness in mind. The problem space here is, a way to encode the state of a row, column and region (sub-grid), given that each number from 1 to 9 are either present or missing. After some time I realized bit-mask is the right tool for this, what's better is that, there are boolean operation that helps combining two encodings. I settled with 1 as missing and 0 as present because of overlooked the operation "binary nor" and "binary and" only works with the chosen schema.
</p>

<p>
So as an example, if there is an encoding of <code>#*111000000</code> this means <code>1,2,3</code> are missing and the rest are present.
</p>
</div>
</div>
<div id="outline-container-org6ae3f81" class="outline-3">
<h3 id="org6ae3f81"><span class="section-number-3">3.2.</span> More on encoding</h3>
<div class="outline-text-3" id="text-3-2">
<p>
let's say i is 0 and j is 6 and we get the following encoding:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">row</td>
<td class="org-left">#*000001001</td>
</tr>

<tr>
<td class="org-left">column</td>
<td class="org-left">#*100011011</td>
</tr>

<tr>
<td class="org-left">region</td>
<td class="org-left">#*001011001</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">and*</td>
<td class="org-left">#*000001001</td>
</tr>
</tbody>
</table>

<p>
The encoding translate back into the possible candidates for this position which are (counted from the LSB as 1):
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">6,</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
My solver started to step through the sudoku and filling in the numbers in their respective positions.
But then it halted at step 10
</p>
</div>
</div>
</div>
<div id="outline-container-org8542daa" class="outline-2">
<h2 id="org8542daa"><span class="section-number-2">4.</span> the second version</h2>
<div class="outline-text-2" id="text-4">
<p>
After looking carefully at the final state of the sudoku puzzle from the currently stuck position, I find out that all the empty spots were having more than 1 possible candidates, this prevented the solver from advancing to the next state.
</p>

<p>
It didn't took long to find out the solver wasn't taking the advantage of the numbers/information from the other "lanes" (rows and/or columns) to help narrow down the choice.
</p>

<pre class="example" id="org183eeac">
―――――――――――――
│...│345│.2.│
│349│7.6│..1│
│2.6│..1│47.│
―――――――――――――
│1.2│.79│.85│
│59.│...│...│
│.6.│...│219│
―――――――――――――
│91.│..7│.42│
│.27│913│.6.│
│...│...│...│
―――――――――――――
</pre>

<p>
Let's look at position <code>(4,0)</code> there are may be up to four possible candidates judging by the 1,2,5,6,9 in the grid. However, if we were to take advantage of the 7s in the grid to the right and below, we can see the only possible place is <code>(4,0)</code>. This way of reasoning is what the algorithm need to progress further from the stuck state.
</p>
</div>
</div>
<div id="outline-container-orga87bb33" class="outline-2">
<h2 id="orga87bb33"><span class="section-number-2">5.</span> the third version</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org74701af" class="outline-3">
<h3 id="org74701af"><span class="section-number-3">5.1.</span> motivation</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Stepping through the sudoku puzzle once more and this time we stopped at step 23.
</p>

<p>
Looking at the message it tells me the solver is unable to find a position with any candidates. Looking at the board right now, I see this is because there are  some contradicting numbers placed onto the board.
</p>

<p>
For instance, the 6 at <code>(0 . 6)</code> should have been a 9 instead. But why did the program decide to put that 6 there. Back to the encodings:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">row</td>
<td class="org-left">#*000001001</td>
</tr>

<tr>
<td class="org-left">column</td>
<td class="org-left">#*100011011</td>
</tr>

<tr>
<td class="org-left">region</td>
<td class="org-left">#*001011001</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">result</td>
<td class="org-left">#*000001001</td>
</tr>

<tr>
<td class="org-left">numbers</td>
<td class="org-left">6, 9</td>
</tr>
</tbody>
</table>

<p>
This tells me the newly added logic that took advantage of the information/numbers from the other lanes has mis-lead the program. Because for <code>(0 . 6)</code> and <code>(0 . 8)</code> either could have put a 6 or 9 down, but due to design of the searcher that simply goes column first then onto the next row meant that <code>(0 . 6)</code> got filled with a <code>6</code>.
</p>

<p>
Time to revise the searcher from positional to regional. The searcher should take into account of the impact of a conflicting choices, which tend to happen to spots within the same row, column or region. Instead of computing for one position at a time, the searcher should compute for 3 rows, 3 columns and 1 region.
</p>
</div>
</div>
<div id="outline-container-org9883dac" class="outline-3">
<h3 id="org9883dac"><span class="section-number-3">5.2.</span> progress</h3>
<div class="outline-text-3" id="text-5-2">
<p>
I thought to myself the best way to approach this is to start with a regional view, where we will consider the problem for all three rows, three columns and one single region.
</p>

<p>
From here the new algorithm is as follows:
</p>
<ul class="org-ul">
<li>Start from one region, typically starts from region X, where X can be anything from 0 to 8</li>
<li>Within region X, there are Y number of empty positions, and Z number of empty positions that has a mask with only 1 bit asserted</li>
<li>there are Y number of masks for each of the empty position, where Y satisfy 0 &lt; Y &lt; X.</li>
<li>From the Y masks there are Z number of masks with only 1 bit asserted</li>
<li>Finally, those Z masks are translated back into the integer to fill back into the Sudoku board.</li>
</ul>

<p>
With the algorithm detailed above implemented after stepping through the program a couple times the Sudoku board is finally solved
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Danny</p>
<p class="date">Created: 2026-01-11 Sun 02:11</p>
</div>
</body>
</html>
